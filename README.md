# lab3
Повторіть хід виконання роботи нижче. Під час виконання інструкцій
ось так будуть виділятись самостійні завдання. Фінальна оцінка за
виконання лабораторної роботи складається із балів, що зазначена в
квадратних дужках в кінці кожного завдання.
Фермерське господарство (симуляція, наприклад, для
комп’ютерної гри)
1. Розробити систему класів «Фермерське господарство». До початкової
структури класів входять: клас Фермерське господарство, що є
основним, клас Рослина, клас Фермер. Поля та властивості класів
вибрати на власний розсуд. Передбачити обов’язкове використання
декількох конструкторів, полів, валідацію даних за допомогою
властивостей.
2. Зробити абстрактним базовий клас Рослина. Ввести до складу
системи, що була створена в лабораторній роботі №3, класи
Однорічна рослина, Плодове дерево, що будуть успадковані від
базового класу Рослина. Розробити інтерфейс взаємодії
фермерського господарства.

Хід виконання

Створіть клас ферми у новому файлі Farm.cs. У нас є приватне поле :
public class Farm
{
private int _plantsLimit;
public string Name { get; set; }
public int PlantsLimit =&gt; _plantsLimit;
}
Створіть запис рослини в файлі Plant.cs:
public class Plant
{
public string ShortName { get; }
public string FullName { get; }
public int GrowingTime { get; }
public bool IsNeedRegrow { get; }
}
Створіть клас Farmer.cs:
public class Farmer
{
public string FirstName { get; set; }
public string LastName { get; set; }
public string Specialization { get; set; }
}
Розширте клас Farm публічними властивостями PlantsOnGrowning, Farmer
із типами List&lt;Plant&gt;, Farmer відповідно. Зверніть увагу що PlantOnGrowing
доступний лише для читання, а фермера можна можна присвоїти лише
зсередини.
public List&lt;Plant&gt; PlantsOnGrowing { get; }
public Farmer? Farmer { get; private set; }
Створіть конструктори у класі Farm.cs:
public Farm() : this(&quot;Farm&quot;)

{}
public Farm(string name) : this(name, 20)
{}
public Farm(string name, int limit) : this(name, limit, null)
{ }
public Farm(string name, int limit, Farmer? farmer)
{
_plantsLimit = limit;
PlantsOnGrowing = new List&lt;Plant&gt;(20);
Farmer = farmer;
}
Як ми бачимо, дані конструктори перевикористовують один одного заради
усунення дублювання коду. Створіть по одному простому конструктору для
записів Plant та Farmer, які будуть ініціалізовувати їх властивості. Обрати
модифікатори доступу для них на власний розсуд[0.5].
Тепер створимо методи для роботи з нашим господарством в класі Farm:
 Метод для додання рослини на вирощення:
public bool AddPlant(Plant plant)
{
if (PlantsOnGrowing.Count == PlantsLimit)
{
return false;
}
PlantsOnGrowing.Add(plant);
return true;
}
 Метод для пошуку рослини (я використав класичний підхід.
Перепишіть метод використовуючи метод класу List для пошуку
елемента Find) [0.5]:
public Plant? FindByPlantName(string name)
{
foreach (var plant in PlantsOnGrowing)
{
if (plant.ShortName == name || plant.FullName == name)
{
return plant;
}
}
return null;
}
 Метод для видалення рослини:
public bool DeletePlant(Plant plant)
{
return PlantsOnGrowing.Remove(plant);
}
Додайте публічний метод для призначення нового фермера. Метод
приймає об’єкт нового фермера і нічого не повертає[0.5].

Додайте валідацію властивостей класів за допомогою set-акцесора.
Як саме і що валідувати – вибір за вами. Рекомендую у випадку
невалідного значення викидати виключення [0.5].
Додайте в сигнатуру запису Plant слово abstract
public abstract class Plant
Додайте в клас Plant віртуальний метод що визначає можливість
отримання нового врожаю з неї. За необхідності додайте нові
властивості для рослини за якими це б визначалось. Спробуйте
продумати комплексну логіку, що не буде залежати від однієї
властивості. [1]
Створіть 2-3 типи рослин: що мають різні додаткові властивості, в
тому числі ті, які можуть змінювати логіку можливості отримання
нового врожаю. [1]
На цьому приклад виконання роботи закінчено. Але, якщо ви хочете
отримати додаткові бали, ви можете внести додатковий функціонал у
клас Farm [1]:
Після того як з моменту додання рослини пройде час, що зазначено в
Plant.GrowingTime автоматично активувати подію PlantGrown, яка
приймає у якості Event Args клас PlantGrownEventArgs:
public class PlantGrownEventArgs
{
public Plant Plant { get; }
public PlantGrownEventArgs(Plant plant)
{
Plant = plant;
}
}
Обробником події повинен бути метод у класі Farmer, що назначений
на дану ферму. Після спрацьовування події фермер повинен
вилучити рослину і посадити нову (того ж типу). Якщо рослина не
потребує пересадки, то таймер повинен перезапускатись
автоматично у випадку якщо у рослини можливо отримати ще один
врожай. Якщо ні – то створіть відповідну логіку.
При видалені рослини раніше терміну необхідно зупинити і видалити
таймер, що з нею пов’язаний.
Не забудьте опрацювати наявність події при зміні/назначені фермера.
